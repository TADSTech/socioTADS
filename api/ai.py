from google import genai
from google.genai import types
import os
from dotenv import load_dotenv
import random
import json
import time
from datetime import datetime, timedelta

load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")

client = genai.Client(api_key=api_key)

# 1. Better Prompts Dictionary
PROMPT_TEMPLATES = {
    "news": (
        "Search for the latest breaking news in Artificial Intelligence and Tech from the last 24 hours. "
        "Choose one significant event and write a tweet summarizing it. "
        "Focus on why it matters to developers."
    ),
    "insight": (
        "Search for trending discussions in software engineering and AI on social media. "
        "Write a thought-provoking tweet offering a unique insight or 'hot take' on a current trend."
    ),
    "tip": (
        "Write a short, practical coding tip or productivity hack for developers using modern AI tools. "
        "Do not search for news, just provide value based on general knowledge."
    ),
    "future": (
        "Search for recent breakthroughs in robotics or quantum computing. "
        "Write a tweet speculating on how this specific breakthrough changes the near future."
    )
}

def generate_tweet(category: str = "news", char_limit: int = 250) -> str:
    """
    Generate a tweet using AI with Google Search capabilities and character limits.
    """
    # Preferred models for high reasoning + search capability
    model = "gemini-2.5-flash" 

    # Construct the final prompt with constraints
    base_prompt = PROMPT_TEMPLATES.get(category, PROMPT_TEMPLATES["news"])
    final_prompt = (
        f"{base_prompt}\n\n"
        f"Constraints:\n"
        f"1. Strictly keep the length under 200 characters(Including white spaces and paragraphs), summarizing in any way shape or form.\n"
        f"2. Use engaging, professional tone.\n"
        f"3. Include 1-2 relevant hashtags at the end only if they do not surpass the 200 character limit.\n"
        f"4. Do not include URLs or markdown formatting like **bold**."
    )

    try:
        print(f"Generating tweet (Category: {category}, Model: {model})...")
        
        # 2. Enable Google Search Tool
        response = client.models.generate_content(
            model=model,
            contents=final_prompt,
            config=types.GenerateContentConfig(
                tools=[types.Tool(google_search=types.GoogleSearch())], # Enables Grounding
                response_mime_type="text/plain"
            )
        )
        
        tweet_text = response.text.strip()
        
        # Fallback length check (just in case)
        if len(tweet_text) > char_limit:
            print(f"Warning: Tweet exceeded limit ({len(tweet_text)} chars). Truncating.")
            tweet_text = tweet_text[:char_limit-3] + "..."
            
        return tweet_text

    except Exception as e:
        print(f"Error generating tweet: {e}")
        return "AI update: Exploring the future of tech! #AI #Tech"

def injectJsonData(category: str = "news", schedule_hours: int = 2, char_limit: int = 280):
    """Generate a new tweet and append it to content.json"""
    try:
        # Path to the content.json file
        json_path = ".github/json/content.json"

        # Read existing data
        if os.path.exists(json_path):
            with open(json_path, 'r') as f:
                posts = json.load(f)
        else:
            posts = []

        # Generate new tweet content
        tweet_text = generate_tweet(category=category, char_limit=char_limit)

        # Generate unique ID and timestamp
        timestamp = int(time.time() * 1000)
        post_id = f"post_{timestamp}"

        # Schedule for future
        future_time = datetime.now() + timedelta(hours=schedule_hours)
        time_str = future_time.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]

        # Create new post entry
        new_post = {
            "id": post_id,
            "text": tweet_text,
            "time": time_str,
            "image": None,
            "hashtags": [], # Hashtags are now inside the text generated by AI
            "posted": False
        }

        posts.append(new_post)

        with open(json_path, 'w') as f:
            json.dump(posts, f, indent=2)

        print(f"Success! Added post {post_id}")
        print(f"Content: {tweet_text}")
        print(f"Scheduled: {time_str}")

        return new_post

    except Exception as e:
        print(f"Error injecting JSON data: {e}")
        return None

def main():
    # Randomly select a category to keep content fresh
    categories = list(PROMPT_TEMPLATES.keys())
    selected_category = random.choice(categories)
    
    # 3. Apply limits and category
    injectJsonData(
        category=selected_category, 
        schedule_hours=2, 
        char_limit=280 # Enforce your free plan limit here
    )

if __name__ == "__main__":
    main()